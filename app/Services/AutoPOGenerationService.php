<?php

namespace App\Services;

use App\Models\NotificationLog;
use App\Models\ProductMinMaxLevel;
use App\Models\ProductStock;
use App\Models\StoreDetail;
use App\Models\StoreOrderSchedule;
use App\Models\StorePurchaseOrder;
use App\Models\StorePurchaseOrderItem;
use App\Models\StoreStock;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class AutoPOGenerationService
{
    /**
     * Check if a store already has an open (pending/approved/dispatched) PO
     * containing a specific product. Used to block duplicate orders.
     */
    public static function hasPendingPO(int $storeId, int $productId): bool
    {
        return StorePurchaseOrderItem::whereHas('storePurchaseOrder', function ($q) use ($storeId) {
            $q->where('store_id', $storeId)
              ->whereIn('status', [
                  StorePurchaseOrder::STATUS_PENDING,
                  StorePurchaseOrder::STATUS_APPROVED,
                  StorePurchaseOrder::STATUS_DISPATCHED,
              ]);
        })
        ->where('product_id', $productId)
        ->whereIn('status', [
            StorePurchaseOrderItem::STATUS_PENDING,
            StorePurchaseOrderItem::STATUS_APPROVED,
            StorePurchaseOrderItem::STATUS_DISPATCHED,
        ])
        ->exists();
    }

    /**
     * Auto-generate a PO for a single store based on StoreStock min/max levels.
     * Returns the created StorePurchaseOrder or null if nothing needed.
     */
    public static function generateForStore(StoreDetail $store, array $recipients = []): ?StorePurchaseOrder
    {
        // Get all store stocks that are at or below min_stock
        $lowStocks = StoreStock::where('store_id', $store->id)
            ->whereColumn('quantity', '<=', 'min_stock')
            ->with('product')
            ->get();

        if ($lowStocks->isEmpty()) {
            Log::info("[AutoPO] Store #{$store->id} ({$store->store_name}): No low-stock items found.");
            return null;
        }

        $itemsToOrder = [];

        foreach ($lowStocks as $storeStock) {
            if (!$storeStock->product || !$storeStock->product->is_active) {
                continue;
            }

            // Skip if there's already an open PO for this product+store
            if (self::hasPendingPO($store->id, $storeStock->product_id)) {
                Log::info("[AutoPO] Store #{$store->id}: Skipping product #{$storeStock->product_id} â€” open PO exists.");
                continue;
            }

            // Check warehouse stock availability
            $warehouseQty = ProductStock::where('product_id', $storeStock->product_id)
                ->where('warehouse_id', 1)
                ->sum('quantity');

            // ProductMinMaxLevel is not imported? Assume it works or is fully qualified if not used here
            // It is used in original code
            $minMax = ProductMinMaxLevel::where('product_id', $storeStock->product_id)->first();
            $warehouseMin = $minMax?->min_level ?? 0;
            $availableAboveMin = max(0, $warehouseQty - $warehouseMin);

            if ($availableAboveMin <= 0) {
                Log::info("[AutoPO] Store #{$store->id}: Skipping product #{$storeStock->product_id} â€” warehouse at minimum.");
                continue;
            }

            // Replenishment qty = max_stock - current_qty
            $maxLevel = $storeStock->max_stock > 0 ? $storeStock->max_stock : ($storeStock->min_stock * 3);
            $replenishQty = max(1, $maxLevel - $storeStock->quantity);

            // Cap to available warehouse stock (above min)
            $replenishQty = min($replenishQty, $availableAboveMin);

            $itemsToOrder[] = [
                'product_id'    => $storeStock->product_id,
                'requested_qty' => $replenishQty,
                'pending_qty'   => $replenishQty,
            ];
        }

        if (empty($itemsToOrder)) {
            Log::info("[AutoPO] Store #{$store->id}: All low-stock items skipped (duplicates or warehouse constraints).");
            return null;
        }

        // Create the PO in a transaction
        return DB::transaction(function () use ($store, $itemsToOrder, $recipients) {
            $po = StorePurchaseOrder::create([
                'po_number'    => StorePurchaseOrder::generatePONumber(),
                'store_id'     => $store->id,
                'request_date' => now()->toDateString(),
                'status'       => StorePurchaseOrder::STATUS_PENDING,
                'admin_note'   => 'Auto-generated by system based on store stock levels.',
                'created_by'   => null, // system-generated
            ]);

            foreach ($itemsToOrder as $item) {
                StorePurchaseOrderItem::create(array_merge($item, [
                    'store_po_id'    => $po->id,
                    'dispatched_qty' => 0,
                    'status'         => StorePurchaseOrderItem::STATUS_PENDING,
                ]));
            }

            // Log the auto-generation
            NotificationLog::record(
                notificationFor: NotificationLog::FOR_AUTO_PO,
                message: "Auto-generated PO #{$po->po_number} for store {$store->store_name} with " . count($itemsToOrder) . " items.",
                type: NotificationLog::TYPE_IN_APP,
                recipient: 'system',
                relatedId: $po->id
            );

            // In-app notification to warehouse admins
            NotificationService::sendToAdmins(
                'ðŸ¤– Auto PO Generated',
                "PO #{$po->po_number} auto-created for {$store->store_name} (" . count($itemsToOrder) . " items).",
                'info',
                route('warehouse.store-orders.show', $po->id)
            );

            // Email Notifications to Store + Schedule Recipients
            $emails = array_unique(array_merge([$store->email], $recipients));
            foreach ($emails as $email) {
                if ($email && filter_var($email, FILTER_VALIDATE_EMAIL)) {
                    try {
                        \Illuminate\Support\Facades\Mail::to($email)->send(new \App\Mail\StoreOrderCreated($po));
                        Log::info("[AutoPO] Email sent to {$email}");
                    } catch (\Exception $e) {
                        Log::error("[AutoPO] Failed to email {$email}: " . $e->getMessage());
                    }
                }
            }

            Log::info("[AutoPO] Created PO #{$po->po_number} for store {$store->store_name} with " . count($itemsToOrder) . " items.");

            return $po;
        });
    }

    /**
     * Run auto-generation for ALL active stores.
     * Returns array of created POs.
     */
    public static function generateForAllStores(): array
    {
        $stores = StoreDetail::where('is_active', true)->get();
        $created = [];
        $todayDay = Carbon::now()->format('l'); // e.g., "Monday"

        foreach ($stores as $store) {
            try {
                // Check for ANY active schedules
                $schedules = StoreOrderSchedule::where('store_id', $store->id)
                    ->where('is_active', true)
                    ->get();

                // If no schedule exists, default to MANUAL ONLY (skip auto-generation)
                if ($schedules->isEmpty()) {
                    Log::info("[AutoPO] Store #{$store->id}: Skipping (No active schedule found).");
                    continue;
                }

                // Check if today is one of the scheduled days
                $todaySchedule = $schedules->first(function ($schedule) use ($todayDay) {
                    return strcasecmp($schedule->expected_day, $todayDay) === 0;
                });

                if (!$todaySchedule) {
                    $scheduledDays = $schedules->pluck('expected_day')->implode(', ');
                    Log::info("[AutoPO] Store #{$store->id}: Skipping (Scheduled for [{$scheduledDays}], today is {$todayDay}).");
                    continue;
                }

                // Optional: Check Cutoff Time (assuming command runs at correct time or we check here)
                
                // Fetch recipients from schedule
                $recipients = $todaySchedule->notification_recipients ?? [];

                // If scheduled for today, proceed
                $po = self::generateForStore($store, $recipients);
                if ($po) {
                    $created[] = $po;
                }
            } catch (\Exception $e) {
                Log::error("[AutoPO] Failed for store #{$store->id}: " . $e->getMessage());
            }
        }

        return $created;
    }
}
